from pydantic import BaseModel, ConfigDict, EmailStr, Field # Imports BaseModel from Pydantic that we use to define data models for validation which ensures incoming data is the right kind like strings , floats and so on. COnfigDict constructs a dictionary of configuration options. 
from typing import  Optional, List, Dict, Any # Imported to give typing support
from datetime import datetime # Imports datetime to handle date & time fields

# USER SCHEMAS
# Creates a class that inherits from BaseModel and determines the user model ensuring required fields of name and email are included and valid.
class AdminUser(BaseModel):
    first_name: str = Field(..., min_length=2) # Ensures first name is not an empty string
    last_name: str = Field(..., min_length=2) # Ensures last name is not an empty string
    email: EmailStr # Enforces email format

class AdminRegistration(AdminUser):
    pass

# Creates a class that inherits from User Base and verifies a user ensuring required fields are present plus a password
class Create_AdminUser(AdminUser):
    password: str # Password Field Declared as a string

# Creates a class that inherits everything from the verified user and reads the data but adds fields generated by the database
class Read_Adminuser(AdminUser):
    id: int # id Field Declared as an integer
    is_verified: bool # Enforces the user's email is verified
    created_at: datetime # Timestamp for when user was created

# Creates a class that inherits from Base Model to facilitate password changing
class PwdChange(BaseModel):
    old_pwd: str # Old password declared as a string
    new_pwd: str # Old password declared as a string

    model_config = ConfigDict(from_attributes=True) # Pydantic V2 Part where models use a special config dictionary instead ofa class like in v1 to set global options for how the model should behave

# Creates a class that inherits from BaseModel and determines the user model ensuring required fields of names, email & password are included and valid.
class UserBase(BaseModel):
    first_name: str = Field(..., min_length=2) # Ensures first name is not an empty string
    last_name: str = Field(..., min_length=2) # Ensures last name is not an empty string
    email: EmailStr # Enforces email format

# Creates a class that inherits everything from the user base Class and creates a new user
class CreateUser(UserBase):
    password: str = Field(..., min_length=8) # Ensures a user creates a password

# Creates a class that inherits everything from the user Class and retruns user data but adds fields generated by the database
class ReadUser(UserBase):
    id: int # User ID from the database
    user_type: str # Indicates whether user is "admin" or "client"
    is_verified: bool # Enforces the user's email is verified
    created_at: datetime # Timestamp for when user was created
    verified_at: Optional[datetime] # Timestamp of last verification which is nullable 
    
    # Allows Object Relational Mapping to Pydantic conversion, populates from alias if needed and excludes None fields automatically in responses
    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# USER PROFILE SCHEMAS
# Creates a class that inherits from BaseModel and determines the user profile model ensuring required fields are included and valid.
class UserProfile(BaseModel):
    user_id: int
    name: Optional[str] = None
    location: Optional[str] = None

# Creates a class that inherits everything from the user profile Class and creates a new user-profile
class CreateUserProfile(UserProfile):
    pass

# Creates a class that inherits everything from the user profile Class and returns user profile data but adds fields generated by the database
class ReadUserProfile(UserProfile):
    id: int # User ID from the database
    created_at: datetime # Timestamp for when user was created
    updated_at: Optional[datetime] # Timestamp of last update which is nullable 
    
    # Allows Object Relational Mapping to Pydantic conversion, populates from alias if needed and excludes None fields automatically in responses
    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# Creates a class that inherits from BaseModel and determines the user profile is updaed while ensuring required fields are included and valid.
class UserProfileUpdate(BaseModel):
    name: Optional[str] = Field(None, max_length=200)
    location: Optional[str] = Field(None, max_length=100)
    role: Optional[str] = Field(None, max_length=100)

# AUTHENTICATION SCHEMAS
# Defines the login request structure requiring a valid email and a password string
class LoginRequest(BaseModel):
    email: EmailStr # Enforces proper email format
    password: str # Requires a password string

# Defines the registration request structure requiring user details with validations
class RegisterRequest(BaseModel):
    first_name: str = Field(..., min_length=2) # Ensures first name is at least 2 characters
    last_name: str = Field(..., min_length=2)  # Ensures last name is at least 2 characters
    email: EmailStr  # Enforces proper email format
    password: str = Field(..., min_length=8) # Requires a strong password (
    confirm_password: str = Field(..., min_length=8)  # Confirms password match

# Defines the response format for an authenitifcation response including optional data and error code
class AuthResponse(BaseModel):
    success: bool # Indicates if the login was successful
    message: str # Provides status of the login attempt
    data: Optional[dict] = None # Contains additional data if successful
    error_code: Optional[str] = None # Optional error code for failed logins

LoginResponse = AuthResponse
RegisterResponse = AuthResponse
LogoutResponse = AuthResponse 

# AUDIT LOG SCHEMAS
# Creates a class that inherits from BaseModel and determines the audit log model ensuring required fields are included and valid.
class AuditLogBase(BaseModel):
    action: str = Field(..., description="Action performed e.g. login, logout, form_submit") # Required field describing what was done
    resource_type: Optional[str] = Field(None, description="Type of resource affected e.g. form, question, user") # Optional field for resource type
    resource_id: Optional[str] = Field(None, description="ID of the affected resource") # Optional ID of resource
    ip_address: Optional[str] = Field(None, description="IP address of the user") # Optional IP address
    user_agent: Optional[str] = Field(None, description="Browser/client information") # Optional client info
    method: Optional[str] = Field(None, description="HTTP method used e.g. GET, POST") # Optional HTTP method
    details: Optional[Dict[str, Any]] = Field(None, description="Additional event-specific data") # Optional metadata dictionary
    status: str = Field(default="success", description="Outcome of the event e.g. success, failure, error") # Status defaults to success
    error_message: Optional[str] = Field(None, description="Error details if status is failure/error") # Error details if any

# Creates a class that inherits everything from the audit log base class and adds user/admin identifiers
class CreateAuditLog(AuditLogBase):
    user_id: Optional[int] = Field(None, description="ID of the user who performed the action") # Optional link to normal user
    admin_id: Optional[int] = Field(None, description="ID of the admin user who performed the action") # Optional link to admin user

# Creates a class that inherits everything from the audit log base class and returns log data but adds fields generated by the database
class ReadAuditLog(AuditLogBase):
    id: int # Unique ID for the audit log record
    user_id: Optional[int] = None # Linked user ID if applicable
    admin_id: Optional[int] = None # Linked admin user ID if applicable
    timestamp: datetime # Timestamp when the event occurred

    # Allows Object Relational Mapping to Pydantic conversion, populates from alias if needed and excludes None fields automatically in responses
    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# Creates a class that inherits from BaseModel to provide basic user info inside audit logs
class AuditUserInfo(BaseModel):
    id: int # User ID from the database
    name: str # User's name
    email: str # User's email address

    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# Creates a class that inherits from BaseModel to provide basic admin info inside audit logs
class AuditAdminInfo(BaseModel):
    id: int # Admin ID from the database
    name: str # Admin's name
    email: str # Admin's email address

    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# Creates a class that extends ReadAuditLog and includes nested user/admin details for more human-readable responses
class ReadAuditLogWithUser(ReadAuditLog):
    user: Optional[AuditUserInfo] = None # Nested user details if action was performed by a normal user
    admin: Optional[AuditAdminInfo] = None # Nested admin details if action was performed by an admin user

# ITEM SCHEMAS
# Creates a class that inherits from BaseModel and determines the Item model ensuring all required fields are included and valid.
class ItemSchema(BaseModel):
    name: str  # Name Field Declared as a string
    base_co2: float  # Base_CO2 Field Declared as a float
    category_name: str  # Foreign key reference to Category, ensures every Item belongs to a Category

# Creates a class that inherits everything from the Item Class and makes a new item
class CreateItem(ItemSchema):
    pass

# Creates a class that inherits everything from the Item Class and reads the data but adds fields generated by the database
class ReadItem(ItemSchema):
    id: int  # id Field Declared as an integer
    count: int # Count Field Declared as an integer
   # category: ReadCategory  # Nested Category Schema ensures items always include their category details

    # Allows Object Relational Mapping to Pydantic conversion, populates from alias if needed and excludes None fields automatically in responses
    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)

# CATEGORY CHEMAS
# Creates a class that inherits from BaseModel and determines the Category model ensuring all required fields are included and valid. 
class Category(BaseModel):
    name: str # Name Field Declared as a string
    description: Optional[str] = None # Optional description

# Creates a class that inherits everything from the Category Class and makes a new category
class CreateCategory(Category):
    pass

# Creates a class that inherits everything from the Category Class and reads the data but adds fields generated by the database
class ReadCategory(Category):
    id: int # id Field Declared as an integer
    items: List[ItemSchema] = []  # Nested items list

    # Allows Object Relational Mapping to Pydantic conversion, populates from alias if needed and excludes None fields automatically in responses
    model_config = ConfigDict(from_attributes=True, populate_by_name=True, exclude_none=True)